For my heap page implementation, I decided to use eager compaction and implemented that in the deletion. 
This allowed me to somewhat simplify the process for handling each new slot offset. The header design is set up with
Page Metadata: pageId, number of slots stored, offset of free space. Each slot metadata is formatted as Slot Metadata: 
slotId, length of slot, offset of slot, where the offset is the end of the slot as stored in the body. 
Adding a value is done by first calculating if there is enough available free space. If there is, I find the lowest
available slotId number. This is done by iterating through the currently used slotIds and finding the smallest number
not in that list. Since I used eager compaction, the new slot offset is the same as the offset stored in the page metadata.
Deleting a value requires compaction each time. Taking the slotId to be deleted, if it is found in the slot metadata,
I remove that particular metadata and shift forward all metadata that follows. Eager compaction makes it so that the order
of my slots in the body is the reverse of the order of the stored slot metadata. At this stage, I also need to change each
slot's offset which is the current slot offset plus the length of the deleted slot for all slots following the deleted one.
I also update the number of slots and free space offset. Then, I copy all the body bytes up until right before the deleted
values into the shifted space. 
I chose to use eager compaction because it simplified the mathematical calculations needed for indexing into the data. It 
also helped me keep track of the slot data better.

I spent three days working on the project (around 10 hours total). Understanding the assignment and slotted page functionalities
took the longest time. Debugging for the stress test also took awhile. I didn't really understand the instructions for the
Page struct. The project write up made it seem like the Page struct was the slotted page, so I was really confused on where
to start.